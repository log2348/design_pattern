package factory;

/**
 * 
 * 팩토리 패턴 (팩토리 메소드 패턴: Factory Method Pattern)
 * 가장 유명한 디자인 패턴 중 하나
 * 생성 패턴 중에 하나이다.
 * 
 * - 생성 패턴은 인스턴스를 만드는 절차를 추상화 하는 패턴이다.
 * - 생성 패턴에 속하는 패턴들은 객체를 생성, 합성하는 방법이나 객체의 표현 방법을 시스템과 분리해준다.
 * - 생성 패턴은 시스템이 상속보다 복합 방법을 사용하는 방향으로 진화되어 가면서 중요성이 더해지고 있다.
 * 
 * 생성 패턴에서의 중요한 이슈 2가지
 * 1. 생성 패턴은 시스템이 어떤 Concrete Class(구체적인 클래스)를 사용하는지에 대한 정보를 캡슐화합니다.
 * 2. 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 결합하는지에 대한 부분을 완전히 가려준다.
 * 
 * 즉, 팩토리 패턴이란
 * 객체를 생성하는 인터페이스는 미리 정의하되,
 * 인스턴스를 만들 클래스의 결정은 서브 클래스 쪽에서 내리는 패턴이다.
 * 다시 말해, 여러 개의 서브 클래스를 가진 슈퍼 클래스가 있을 때
 * 인풋에 따라 하나의 자식 클래스를 인스턴스해서 리턴해 주는 방식이다.
 *
 * 팩토리 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브 클래스로 미룬다.
 * 
 * 활용성
 * 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
 * 생성할 객체를 기술하는 책임을 자신이 아니고 서브 클래스가 지정했으면 할 때
 * 
 * 추가 설명
 * 팩토리 패턴의 장점
 * 팩토리 패턴은 클라이언트 코드로부터 서브 클래스의 인스턴스화를 제거하여
 * 서로 간에 종속성을 낮추고 결합도를 느슨하게 하며 확장을 쉽게 한다.
 * 
 * 예를 들어 PC 클래스에 대해 수정 혹은 삭제가 일어나도 클라이언트는 알 수 없기 때문에
 * 코드를 변경할 필요도 없다.
 * 
 * 팩토리 패턴은 클라이언트와 구현 객체들 사이에 추상화를 제공한다.
 * 
 */
public class MainTest {

	public static void main(String[] args) {
		
		// 팩토리 - 객체를 생성시킬 때 사용, 어떤 객체인지는 감춰져있다
		// 구현해야하는 객체에 대한 책임은 서브 클래스가 갖는 것 -> Loose Coupling, 확장성, 유지보수 용이
		Computer computer = ComputerFactory.getComputer("PC", "32", "1TB", "ARM");
		System.out.println(computer);

		Computer computer2 = ComputerFactory.getComputer("NOTEBOOK", "16", "500", "Intel");
		System.out.println(computer2);
		
	}

}
